/*
请你来实现一个 atoi 函数，使其能将字符串转换成整数。

首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。

当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。

该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。

注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。

在任何情况下，若函数不能进行有效的转换时，请返回 0。

说明：

假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 
*/

/*解题思路：
我解题的核心在于 寻找有效数字串，因此
1.先去空格，从前往后遍历寻找第一个"-","+","0-9",记录当前有效串起始位置
2.判断有效串正负值，使用flag来记录
3.寻找到有效串的结束为止，即该字符不为"0-9"
4.获取有效串的起始位置和结束位置，开始转换
##重点是转换需要判断是否溢出，这个比较头疼！！！
也是利用无符号u64来记录数字，如果x+y<x，则溢出，同时需要判断长度过长时，也会溢出
某些测试例居然避开了第一个判断，因此需要补充长度>10且字符不为0溢出判断。
最后需要把u64转成int类型，同时根据flag返回正负值。
leetcode这题居然击败100% c用户？？
*/

int myAtoi(char * str)
{
    int i, j, k, m = 0;
    int len = strlen(str);
    int flag = 0;//0表示正数，1表示负数，2表示+正数
    unsigned long long  num = 0;
    unsigned long long total = 0;
    int ret;
    
	//找到起始位置
    for (i = 0; i<len; i++){
        if (str[i] != ' ')
            break;
    }
    
    if (i == len)
    	return 0;
	
	//判断flag
   	if (str[i] == '-'){
		flag = 1;
		i++;   
	}else if(str[i] == '+'){
		flag = 2;
		i++;
	}else if(str[i]>= '0' && str[i]<= '9'){

	}else{
		return 0;
	}
	if (i == len){
		return 0;
	}
	//找到结束位置
	for (j = i; j<len; j++){
		if (str[j]<'0' || str[j]>'9'){
			break;
		}
	}

	//valid [i]-[j-1]，计算值，解决溢出
	for (k = j-1; k>=i; k--){
		if (m == 0)
			num = 1;
		else
			num = num*10;
		m++;
		total = total+num*(str[k]-'0');
		if ((m>10 && str[k] != '0') || (total<num*(str[k]-'0'))){
			if (flag != 1){
				return 2147483647;
			}else{
				return (-2147483648);
			} 
		}
	}
    
	if (flag != 1 && total>=2147483647){
		return 2147483647;
	}else if(total>=2147483648){
		return (-2147483648);
	}
    //类型转换成int
	ret = (int)total;
	//处理负值，反码+1
	if (flag == 1){
		ret = ~ret+1;	
	}

	return ret;
	
}